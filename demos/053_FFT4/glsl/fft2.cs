#version 430 core

uniform float time;

//========================================================================================================================================================================================================================
// The shader does n x n FFT algorithm
//========================================================================================================================================================================================================================
const int n = 1024;
const int m = 10;          // = log2(n)

//========================================================================================================================================================================================================================
// Input buffer :: the input data is a complex (packed as vec2) N x N matrix
// No bit reversing step is performed, therefore the first butterfly step should be different from the
// following and essentially perform both bit reversing and butterfly.
// It make sence to separate it in any case as for the first butterfly step roots of unity 
// are so simple that no complex multiplication is required at all
//========================================================================================================================================================================================================================
layout (rg32f, binding = 0) uniform imageBuffer input_buffer;
layout (rg32f, binding = 1) uniform imageBuffer output_buffer;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

shared vec2 X[n];

int bit_reverse(int q)
{
    const int br[16] = {0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe, 0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf};
    return (br[q & 0xF] << 4) + br[q >> 4];
}

vec2 cmul(vec2 z, vec2 w)
{
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

void main(void)
{

    int iX = int(gl_GlobalInvocationID.x);
    int iY = int(gl_GlobalInvocationID.y);

    //====================================================================================================================================================================================================================
    // Perform initial texture buffer row read and FFT4 step simultaneously to fill shared x array
    //====================================================================================================================================================================================================================

    int q = bit_reverse(iX);

    vec2 u0 = imageLoad(input_buffer, n * iY + 0x000 + q).rg;
    vec2 u1 = imageLoad(input_buffer, n * iY + 0x200 + q).rg;
    vec2 u2 = imageLoad(input_buffer, n * iY + 0x100 + q).rg;
    vec2 u3 = imageLoad(input_buffer, n * iY + 0x300 + q).rg;

    vec2 v0 = u0 + u1;
    vec2 v1 = u0 - u1;
    vec2 v2 = u2 + u3;
    vec2 v3 = u2 - u3;

    vec2 iv3 = vec2(-v3.y, v3.x);

    X[4 * iX + 0] = v0 +  v2;
    X[4 * iX + 1] = v1 + iv3;
    X[4 * iX + 2] = v0 -  v2;
    X[4 * iX + 3] = v1 - iv3;

    //====================================================================================================================================================================================================================
    // The main loop performing FFT4 steps
    //====================================================================================================================================================================================================================
    int p2 = 4;                 // current butterfly step size
    float freq = 0.0625;

    for(int i = 0; i < 4; ++i)
    {
        //================================================================================================================================================================================================================
        // Useful preparation work before synchronization call:
        //   -- determine base index this shader invocation will work on
        //   -- prepare twiddle factors 
        //================================================================================================================================================================================================================
        int mask = p2 - 1;
        int q = iX & ~mask;
        int r = iX &  mask;
        int base_index = 3 * q + iX;
        float arg = freq * r;

        vec2 w = vec2(sin(arg), cos(arg)); 
        vec2 iw = vec2(-w.y, w.x);
        vec2 ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

        //================================================================================================================================================================================================================
        // Wait when this workgroup invocations will finish their writes to X
        //================================================================================================================================================================================================================
        barrier();

        //================================================================================================================================================================================================================
        // Now do this fucking FFT4 step!
        //================================================================================================================================================================================================================
        u0 = X[base_index + 0 * p2];
        u1 = X[base_index + 1 * p2];
        u2 = X[base_index + 2 * p2];
        u3 = X[base_index + 3 * p2];

        vec2 wwu1 = cmul(ww, u1); 
        vec2 wwu3 = cmul(ww, u3); 

        v0 = u0 + wwu1;
        v1 = u0 - wwu1;
        v2 = u2 + wwu3;
        v3 = u2 - wwu3;

        vec2  wv2 = cmul( w, v2); 
        vec2 iwv3 = cmul(iw, v3); 


        X[base_index + 0 * p2] = v0 +  wv2;
        X[base_index + 1 * p2] = v0 -  wv2;
        X[base_index + 2 * p2] = v1 + iwv3;
        X[base_index + 3 * p2] = v1 - iwv3;

        p2 <<= 2;
    }

    barrier();

    imageStore(output_buffer, n * iY + 4 * iX + 0, vec4(X[4 * iX + 0], 0.0, 0.0));
    imageStore(output_buffer, n * iY + 4 * iX + 1, vec4(-X[4 * iX + 1], 0.0, 0.0));
    imageStore(output_buffer, n * iY + 4 * iX + 2, vec4(X[4 * iX + 2], 0.0, 0.0));
    imageStore(output_buffer, n * iY + 4 * iX + 3, vec4(-X[4 * iX + 3], 0.0, 0.0));

    //====================================================================================================================================================================================================================
    // Syncronize image store operations
    //====================================================================================================================================================================================================================
//    memoryBarrier();


    //====================================================================================================================================================================================================================
    // Now we do vertical FFT transform
    //====================================================================================================================================================================================================================

/*
    vec2 e0 = imageLoad(output_buffer, n * (q + 0x000) + iY).rg;
    vec2 e1 = imageLoad(output_buffer, n * (q + 0x200) + iY).rg;
    vec2 e2 = imageLoad(output_buffer, n * (q + 0x100) + iY).rg;
    vec2 e3 = imageLoad(output_buffer, n * (q + 0x300) + iY).rg;

    memoryBarrier();

    imageStore(output_buffer, n * (4 * iX + 0) + iY, vec4(e0, 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 1) + iY, vec4(e1, 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 2) + iY, vec4(e2, 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 3) + iY, vec4(e3, 0.0, 0.0));
*/
/*
    u0 = imageLoad(output_buffer, n * (q + 0x000) + iY).rg;
    u1 = imageLoad(output_buffer, n * (q + 0x200) + iY).rg;
    u2 = imageLoad(output_buffer, n * (q + 0x100) + iY).rg;
    u3 = imageLoad(output_buffer, n * (q + 0x300) + iY).rg;


    v0 = u0 + u1;
    v1 = u0 - u1;
    v2 = u2 + u3;
    v3 = u2 - u3;

    iv3 = vec2(-v3.y, v3.x);

    X[4 * iX + 0] = v0 +  v2;
    X[4 * iX + 1] = v1 + iv3;
    X[4 * iX + 2] = v0 -  v2;
    X[4 * iX + 3] = v1 - iv3;

    //====================================================================================================================================================================================================================
    // The main loop performing FFT4 steps
    //====================================================================================================================================================================================================================
    p2 = 4;
    freq = 0.0625;

    for(int i = 0; i < 3; ++i)
    {
        //================================================================================================================================================================================================================
        // Useful preparation work before synchronization call:
        //   -- determine base index this shader invocation will work on
        //   -- prepare twiddle factors 
        //================================================================================================================================================================================================================
        int mask = p2 - 1;
        int q = iX & ~mask;
        int r = iX &  mask;
        int base_index = 3 * q + iX;
        float arg = freq * r;

        vec2 w = vec2(sin(arg), cos(arg)); 
        vec2 iw = vec2(-w.y, w.x);
        vec2 ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

        //================================================================================================================================================================================================================
        // Wait when this workgroup invocations will finish their writes to X
        //================================================================================================================================================================================================================
        barrier();

        //================================================================================================================================================================================================================
        // Now do this fucking FFT4 step!
        //================================================================================================================================================================================================================
        u0 = X[base_index + 0 * p2];
        u1 = X[base_index + 1 * p2];
        u2 = X[base_index + 2 * p2];
        u3 = X[base_index + 3 * p2];

        vec2 wwu1 = cmul(ww, u1); 
        vec2 wwu3 = cmul(ww, u3); 

        v0 = u0 + wwu1;
        v1 = u0 - wwu1;
        v2 = u2 + wwu3;
        v3 = u2 - wwu3;

        vec2  wv2 = cmul( w, v2); 
        vec2 iwv3 = cmul(iw, v3); 


        X[base_index + 0 * p2] = v0 +  wv2;
        X[base_index + 1 * p2] = v0 -  wv2;
        X[base_index + 2 * p2] = v1 + iwv3;
        X[base_index + 3 * p2] = v1 - iwv3;

        p2 <<= 2;
    }

    barrier();

    imageStore(output_buffer, n * (4 * iX + 0) + iY, vec4(X[4 * iX + 0], 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 1) + iY, vec4(X[4 * iX + 1], 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 2) + iY, vec4(X[4 * iX + 2], 0.0, 0.0));
    imageStore(output_buffer, n * (4 * iX + 3) + iY, vec4(X[4 * iX + 3], 0.0, 0.0));
*/
}