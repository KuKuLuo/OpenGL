#version 430 core

uniform float time;

//========================================================================================================================================================================================================================
// The shader does horizontal FFT transform for a 2D n x n input 
//========================================================================================================================================================================================================================
#define n 1024
#define m 10

//========================================================================================================================================================================================================================
// Input buffer :: the input data is a complex (packed as vec2) N x N matrix
// No bit reversing step is performed, therefore the first butterfly step should be different from the
// following and essentially perform both bit reversing and butterfly.
// It make sence to separate it in any case as for the first butterfly step roots of unity 
// are so simple that no multiplication is required at all
//========================================================================================================================================================================================================================
layout (rg32f, binding = 0) uniform imageBuffer input_buffer;
layout (rg32f, binding = 1) uniform imageBuffer output_buffer;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

shared vec2 Z[n];

int bit_reverse256(int q)
{
    const int br[16] = {0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF};
    return (br[q & 0xF] << 4) + br[q >> 4];
}

vec2 cmul(vec2 z, vec2 w)
{
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float hash(float iX, float iY) 
{
    float h = 127 * iX + 311 * iY;
    return fract(sin(h) * 43758.5453123) - 0.5;
}

void main(void)
{
    //====================================================================================================================================================================================================================
    // Find out who da fuck we are
    //====================================================================================================================================================================================================================
    int iX = int(gl_GlobalInvocationID.x);
    int iY = int(gl_GlobalInvocationID.y);
    int q = bit_reverse256(iX);
    int b = (iY << m) + q;

    //====================================================================================================================================================================================================================
    // Perform initial texture buffer row read and initial FFT4 step simultaneously to fill shared x array
    //====================================================================================================================================================================================================================

    /* Fill in the spectral coefficients */

    vec2 u0 = imageLoad(input_buffer, b + 0x000).rg;
    vec2 u1 = imageLoad(input_buffer, b + 0x200).rg;
    vec2 u2 = imageLoad(input_buffer, b + 0x100).rg;
    vec2 u3 = imageLoad(input_buffer, b + 0x300).rg;

    float phi0 = 4.85 * hash(q + 0x000, iY) * time;
    float phi1 = 4.85 * hash(q + 0x200, iY) * time;
    float phi2 = 4.85 * hash(q + 0x100, iY) * time;
    float phi3 = 4.85 * hash(q + 0x300, iY) * time;

    vec2 r0 = vec2(cos(phi0), sin(phi0));
    vec2 r1 = vec2(cos(phi1), sin(phi1));
    vec2 r2 = vec2(cos(phi2), sin(phi2));
    vec2 r3 = vec2(cos(phi3), sin(phi3));

    u0 = cmul(u0, r0);
    u1 = cmul(u1, r1);
    u2 = cmul(u2, r2);
    u3 = cmul(u3, r3);



    vec2 v0 = u0 + u1;
    vec2 v1 = u0 - u1;
    vec2 v2 = u2 + u3;
    vec2 v3 = u2 - u3;

    vec2 iv3 = vec2(-v3.y, v3.x);

    Z[4 * iX + 0] = v0 +  v2;
    Z[4 * iX + 1] = v1 + iv3;
    Z[4 * iX + 2] = v0 -  v2;
    Z[4 * iX + 3] = v1 - iv3;

    //====================================================================================================================================================================================================================
    // The main loop performing FFT4 steps
    //====================================================================================================================================================================================================================
    const float pi = 3.141592653589793238462643383279502884197169399375105820974;
    float freq = 0.125 * pi;

    int p2 = 4;                 // current butterfly stride
    int mask, h;
    float arg;

    vec2 w, iw, ww, wwu1, wwu3, wv2, iwv3;

    for(int i = 0; i < (m - 4) / 2; ++i)
    {
        //================================================================================================================================================================================================================
        // Useful preparation work before synchronization call:
        //   -- determine base index this shader invocation will work on
        //   -- prepare twiddle factors 
        //================================================================================================================================================================================================================
        mask = p2 - 1;
        h = iX & ~mask;
        b = 3 * h + iX;
        arg = freq * (iX & mask);

         w = vec2(cos(arg), sin(arg)); 
        iw = vec2(-w.y, w.x);
        ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

        //================================================================================================================================================================================================================
        // Wait when this workgroup invocations will finish their writes to X
        //================================================================================================================================================================================================================
        barrier();

        //================================================================================================================================================================================================================
        // Now do this fucking FFT4 step!
        //================================================================================================================================================================================================================
        u0 = Z[b + 0 * p2];
        u1 = Z[b + 1 * p2];
        u2 = Z[b + 2 * p2];
        u3 = Z[b + 3 * p2];

        vec2 wwu1 = cmul(ww, u1); 
        vec2 wwu3 = cmul(ww, u3); 

        v0 = u0 + wwu1;
        v1 = u0 - wwu1;
        v2 = u2 + wwu3;
        v3 = u2 - wwu3;

         wv2 = cmul( w, v2); 
        iwv3 = cmul(iw, v3);

        Z[b + 0 * p2] = v0 +  wv2;
        Z[b + 1 * p2] = v1 + iwv3;
        Z[b + 2 * p2] = v0 -  wv2;
        Z[b + 3 * p2] = v1 - iwv3;

        p2 <<= 2;
        freq *= 0.25;
    }

    arg = freq * iX;
     w = vec2(cos(arg), sin(arg)); 
    iw = vec2(-w.y, w.x);
    ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

    //====================================================================================================================================================================================================================
    // Wait when this workgroup invocations will finish their writes to X
    //====================================================================================================================================================================================================================
    barrier();

    //================================================================================================================================================================================================================
    // The last FFT4 step!
    //================================================================================================================================================================================================================
    u0 = Z[iX + 0x000];
    u1 = Z[iX + 0x100];
    u2 = Z[iX + 0x200];
    u3 = Z[iX + 0x300];

    wwu1 = cmul(ww, u1); 
    wwu3 = cmul(ww, u3); 

    v0 = u0 + wwu1;
    v1 = u0 - wwu1;
    v2 = u2 + wwu3;
    v3 = u2 - wwu3;

     wv2 = cmul( w, v2); 
    iwv3 = cmul(iw, v3);

    //================================================================================================================================================================================================================
    // Write results immediately to the output buffer avoiding writes to shared X
    //================================================================================================================================================================================================================
    b = (iY << m) + iX;
    imageStore(output_buffer, b + 0x000, vec4(v0 +  wv2, 0.0, 0.0));
    imageStore(output_buffer, b + 0x100, vec4(v1 + iwv3, 0.0, 0.0));
    imageStore(output_buffer, b + 0x200, vec4(v0 -  wv2, 0.0, 0.0));
    imageStore(output_buffer, b + 0x300, vec4(v1 - iwv3, 0.0, 0.0));
}