#version 430 core

uniform float time;

//========================================================================================================================================================================================================================
// The shader does vertical FFT transform for a 2D n x n input 
//========================================================================================================================================================================================================================
#define n 1024
#define m 10

//========================================================================================================================================================================================================================
// Input buffer :: the input data is a complex (packed as vec2) N x N matrix
// No bit reversing step is performed, therefore the first butterfly step should be different from the
// following and essentially perform both bit reversing and butterfly.
// It make sence to separate it in any case as for the first butterfly step roots of unity 
// are so simple that no multiplication is required at all
//========================================================================================================================================================================================================================
layout (rg32f, binding = 1) uniform imageBuffer inout_buffer;

layout (local_size_x = 1, local_size_y = 256, local_size_z = 1) in;

shared vec2 Z[n];

int bit_reverse256(int q)
{
    const int br[16] = {0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe, 0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf};
    return (br[q & 0xF] << 4) + br[q >> 4];
}

vec2 cmul(vec2 z, vec2 w)
{
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

void main(void)
{
    //====================================================================================================================================================================================================================
    // Find out who da fuck we are
    //====================================================================================================================================================================================================================
    int iX = int(gl_GlobalInvocationID.x);
    int iY = int(gl_GlobalInvocationID.y);
    int q = bit_reverse256(iY);
    int b = (q << m) + iX;
    //====================================================================================================================================================================================================================
    // Perform initial texture buffer row read and FFT4 step simultaneously to fill shared x array
    //====================================================================================================================================================================================================================

    vec2 u0 = imageLoad(inout_buffer, b + (0x000 << m)).rg;
    vec2 u1 = imageLoad(inout_buffer, b + (0x200 << m)).rg;
    vec2 u2 = imageLoad(inout_buffer, b + (0x100 << m)).rg;
    vec2 u3 = imageLoad(inout_buffer, b + (0x300 << m)).rg;

    vec2 v0 = u0 + u1;
    vec2 v1 = u0 - u1;
    vec2 v2 = u2 + u3;
    vec2 v3 = u2 - u3;

    vec2 iv3 = vec2(-v3.y, v3.x);

    Z[4 * iY + 0] = v0 +  v2;
    Z[4 * iY + 1] = v1 + iv3;
    Z[4 * iY + 2] = v0 -  v2;
    Z[4 * iY + 3] = v1 - iv3;

    //====================================================================================================================================================================================================================
    // The main loop performing FFT4 steps
    //====================================================================================================================================================================================================================
    const float pi = 3.141592653589793238462643383279502884197169399375105820974;
    float freq = 0.125 * pi;

    int p2 = 4;                 // current butterfly stride
    int mask, h;
    float arg;

    vec2 w, iw, ww, wwu1, wwu3, wv2, iwv3;

    for(int i = 0; i < (m - 4) / 2; ++i)
    {
        //================================================================================================================================================================================================================
        // Useful preparation work before synchronization call:
        //   -- determine base index this shader invocation will work on
        //   -- prepare twiddle factors 
        //================================================================================================================================================================================================================
        mask = p2 - 1;
        h = iY & ~mask;
        b = 3 * h + iY;
        arg = freq * (iY &  mask);

         w = vec2(cos(arg), sin(arg)); 
        iw = vec2(-w.y, w.x);
        ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

        //================================================================================================================================================================================================================
        // Wait when this workgroup invocations will finish their writes to X
        //================================================================================================================================================================================================================
        barrier();

        //================================================================================================================================================================================================================
        // Now do this fucking FFT4 step!
        //================================================================================================================================================================================================================
        u0 = Z[b + 0 * p2];
        u1 = Z[b + 1 * p2];
        u2 = Z[b + 2 * p2];
        u3 = Z[b + 3 * p2];

        wwu1 = cmul(ww, u1); 
        wwu3 = cmul(ww, u3); 

        v0 = u0 + wwu1;
        v1 = u0 - wwu1;
        v2 = u2 + wwu3;
        v3 = u2 - wwu3;

         wv2 = cmul( w, v2); 
        iwv3 = cmul(iw, v3); 

        Z[b + 0 * p2] = v0 +  wv2;
        Z[b + 1 * p2] = v1 + iwv3;
        Z[b + 2 * p2] = v0 -  wv2;
        Z[b + 3 * p2] = v1 - iwv3;

        p2 *= 4;
        freq *= 0.25;
    }

    arg = freq * iY;
     w = vec2(cos(arg), sin(arg)); 
    iw = vec2(-w.y, w.x);
    ww = vec2(w.x * w.x - w.y * w.y, 2.0 * w.x * w.y);

    //====================================================================================================================================================================================================================
    // Wait when this workgroup invocations will finish their writes to X
    //====================================================================================================================================================================================================================
    barrier();

    //====================================================================================================================================================================================================================
    // The last FFT4 step!
    //====================================================================================================================================================================================================================
    u0 = Z[iY + 0x000];
    u1 = Z[iY + 0x100];
    u2 = Z[iY + 0x200];
    u3 = Z[iY + 0x300];

    wwu1 = cmul(ww, u1); 
    wwu3 = cmul(ww, u3); 

    v0 = u0 + wwu1;
    v1 = u0 - wwu1;
    v2 = u2 + wwu3;
    v3 = u2 - wwu3;

     wv2 = cmul( w, v2); 
    iwv3 = cmul(iw, v3); 

    vec2 res0 = v0 +  wv2;
    vec2 res1 = v1 + iwv3;
    vec2 res2 = v0 -  wv2;
    vec2 res3 = v1 - iwv3;

    if (((iY + iX) & 1) == 1)
    {
        res0 = -res0;
        res1 = -res1;
        res2 = -res2;
        res3 = -res3;
    }

    b = (iY << m) + iX;
    imageStore(inout_buffer, b + (0x000 << m), vec4(res0, 0.0, 0.0));
    imageStore(inout_buffer, b + (0x100 << m), vec4(res1, 0.0, 0.0));
    imageStore(inout_buffer, b + (0x200 << m), vec4(res2, 0.0, 0.0));
    imageStore(inout_buffer, b + (0x300 << m), vec4(res3, 0.0, 0.0));
}